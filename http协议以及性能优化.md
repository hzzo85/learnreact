###有待讨论的话题###
回流，重绘，浏览器渲染原理，文档流， 推送

前端向知识点梳理
## 核心知识
必须掌握的，也是最基础的，譬如浏览器模型，渲染原理，JS解析过程，JS运行机制等，作为骨架来承载知识体系

## 重点知识
重点知识，往往每一块都是一个知识点，而且这些知识点都很重要，譬如http相关，web安全相关，跨域处理等

## 拓展知识
拓展知识，这一块可能更多的是了解，稍微实践过，但是认识上可能没有上面那么深刻，譬如五层因特尔协议栈，hybrid模式，移动原生开发，后台相关等等（当然，在不同领域，可能有某些知识就上升到重点知识层次了，譬如hybrid开发时，懂原生开发是很重要的）

## 主干流程梳理
1. 从浏览器接收url到开启网络请求线程（这一部分可以展开浏览器的机制以及进程与线程之间的关系）

2. 开启网络线程到发出一个完整的http请求（这一部分涉及到dns查询，tcp/ip请求，五层因特网协议栈等知识）

3. 从服务器接收到请求到对应后台接收到请求（这一部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等）

4. 后台和前台的http交互（这一部分包括http头部、响应码、报文结构、cookie等知识，可以提下静态资源的cookie优化，以及编码解码，如gzip压缩等）

5. 单独拎出来的缓存问题，http的缓存（这部分包括http缓存头部，etag，catch-control等）

6. 浏览器接收到http数据包后的解析流程（解析html-词法分析然后解析成dom树、解析css生成css规则树、合并成render树，然后layout、painting渲染、复合图层的合成、GPU绘制、外链资源的处理、loaded和domcontentloaded等）

7. CSS的可视化格式模型（元素的渲染规则，如包含块，控制框，BFC，IFC等概念）

8. JS引擎解析过程（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）

9. 其它（可以拓展不同的知识模块，如跨域，web安全，hybrid模式等等内容）

## DETAIL
1. `从浏览器接收url到开启网络请求线程`
展开内容: 浏览器进程/线程模型，JS的运行机制
    a. 多进程的浏览器
        一个主进程，每个tab页会开一个新进程（某些情况会合并）
        进程可能包括主控进程，插件进程，GPU，tab页（浏览器内核）等等。
        * Browser进程：浏览器的主进程（负责协调、主控），只有一个
        * 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建
        * GPU进程：最多一个，用于3D绘制
        * 浏览器渲染进程（内核）：默认每个Tab页面一个进程，互不影响，控制页面渲染，脚本执行，事件处理等（有时候会优化，如多个空白tab会合并成一个进程）
    b. 多线程的浏览器内核
        一个tab页可以看作是一个浏览器内核进程，该进程是多线程的，包括以下子线程：
        * GUI线程
        * JS引擎线程 （JS引擎是内核进程中的一个线程，这也是为什么常说JS引擎是单线程的。）
        * 事件触发线程
        * 定时器线程
        * 网络请求线程
    c. 解析URL（统一资源定位符）
        URL一般包括
        * protocol 协议头
        * host 主机域名或IP地址
        * port
        * path
        * query
        * fragment #后的hash，一般用来定位到某个位置
    d. 网络请求都是单独的线程
        每次网络请求时都需要开辟单独的线程进行，譬如如果URL解析到http协议，就会新建一个网络线程去处理资源下载。

        因此浏览器会根据解析出得协议，开辟一个网络线程，前往请求资源（这里，暂时理解为是浏览器内核开辟的，如有错误，后续修复
    e. More
        从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理：https://segmentfault.com/a/1190000012925872。

2. `开启网络线程到发出一个完整的http请求`
```
这一部分主要包裹： DNS查询， TCP/IP请求构建，五层因特网协议栈等等
    a. DNS 查询得到 IP （如果输入的是域名）
        * 如果浏览器有缓存，直接使用浏览器缓存，否则使用本机缓存，再没有就用host
        * 本地没有，向DNS域名服务器查询（中间可能经过路由，也有缓存）
        DNS解析比较耗时，如果解析域名过多，会让首屏加载过慢（`dns-prefetch`优化）。

    b. TCP/IP 请求
        tcp将http长报文划分为短报文，通过三次握手与服务端建立连接，进行可靠传输。
        `三次握手`
        客户端：hello，你是server么？
        服务端：hello，我是server，你是client么
        客户端：yes，我是client
        ...
        建立连接成功后，接下来就正式传输数据。
        untill
        断开连接时，需要进行四次挥手（因为是全双工的，所以需要四次挥手）
        `四次挥手`
        主动方：我已经关闭了向你那边的主动通道了，只能被动接收了
        被动方：收到通道关闭的信息
        被动方：那我也告诉你，我这边向你的主动通道也关闭了
        主动方：最后收到数据，之后双方无法通信
        `TCP/IP的并发限制`
        浏览器对同一域名下并发的tcp连接是有限制的（2-10个不等）。
        HTTP1.0中一个资源下载对应一个TCP/IP请求
        `GET和POST的区别`
        本质都是TCP/IP， 但两者除了在http层面外，在TCP/IP层面也有区别。

        GET会产生一个TCP数据包，POST两个。
        GET请求时， 浏览器会把 headers 和 data 一起发送出去，服务器响应200（返回数据）

        POST请求时， 浏览器先发送 headers ，服务器响应100 continue， 浏览器再发送data， 服务器响应200（返回数据）。

    c. 五层因特网协议栈
        整体概念： 从客户端发出http请求到服务器接收，中间会经过一系列的流程。
        简单概括就是：从应用层的发送http请求，到传输层通过三次握手建立tcp/ip连接，再到网络层的ip寻址，再到数据链路层的封装成帧，最后到物理层的利用物理介质传输。

        1.应用层(dns,http) DNS解析成IP并发送http请求
        2.传输层(tcp,udp) 建立tcp连接（三次握手）
        3.网络层(IP,ARP) IP寻址
        4.数据链路层(PPP) 封装成帧
        5.物理层(利用物理介质传输比特流) 物理传输（然后传输的时候通过双绞线，电磁波等各种介质）
        OSI七层框架： 物理层、 数据链路层、 网络层、 传输层、 会话层、 表示层、 应用层。
        表示层：主要处理两个通信系统中交换信息的表示方式，包括数据格式交换，数据加密与解密，数据压缩与终端类型转换等

        会话层：它具体管理不同用户和进程之间的对话，如控制登陆和注销过程
    d. 从服务器接收到请求到对应后台接收到请求
    e. 负载均衡
        用户发起的请求都指向调度服务器（反向代理服务器，譬如安装了nginx控制负载均衡），然后调度服务器根据实际的调度算法，分配不同的请求给对应集群中的服务器执行，然后调度器等待实际服务器的HTTP响应，并将它反馈给用户。
    f. 后台的处理
        * 一般有的后端是有统一的验证的，如安全拦截，跨域验证
        * 如果这一步不符合规则，就直接返回了相应的http报文（如拒绝请求等）
        * 然后当验证通过后，才会进入实际的后台代码，此时是程序接收到请求，然后执行（譬如查询数据库，大量计算等等）
        * 等程序执行完毕后，就会返回一个http响应包（一般这一步也会经过多层封装）
        * 然后就是将这个包从后端发送到前端，完成交互
    g. 后台和前台的http交互  *****
        * http 报文结构（通用头部， 请求/响应头部， 请求/响应体）
`       通用头部:`
            Request Url
            Request Method （Get、POST、OPTIONS、PUT、HEAD、DELETE、CONNECT、TRACE）
            Status Code
            Remote Address: 请求的远程服务器地址（会转为IP）
        Method:
            在拒绝跨域时候 Method 为 options Status Code 为 404/405
            HTTP1.0:  GET, POST, HEAD
            HTTP1.1:  OPTIONS, PUT, DELETE, TRACE, CONNECT
        Status Code:
            200——表明该请求被成功地完成，所请求的资源发送回客户端
            304——自从上次请求后，请求的网页未修改过，请客户端使用本地缓存
            400——客户端请求有错（譬如可以是安全模块拦截）
            401——请求未经授权
            403——禁止访问（譬如可以是未登录时禁止）
            404——资源未找到
            500——服务器内部错误
            503——服务不可用
`       请求/响应头部:`
            常用请求头：
                Accept: 接收类型，表示浏览器支持的MIME类型（对标服务端返回的Content-Type）
                Accept-Encoding：浏览器支持的压缩类型,如gzip等,超出类型不能接收
                Content-Type：客户端发送出去实体内容的类型
                Cache-Control: 指定请求和响应遵循的缓存机制，如no-cache
                If-Modified-Since：对应服务端的Last-Modified，用来匹配看文件是否变动，只能精            确到1s之内，http1.0中
                Expires：缓存控制，在这个时间内不会请求，直接使用缓存，http1.0，而且是服务端时          间
                Max-age：代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存，http1.1中
                If-None-Match：对应服务端的ETag，用来匹配文件内容是否改变（非常精确），         http1.1中
                Cookie：有cookie并且同域访问时会自动带上
                Connection：当浏览器与服务器通信时对于长连接如何进行处理,如keep-alive
                Host：请求的服务器URL
                Origin：最初的请求是从哪里发起的（只会精确到端口）,Origin比Referer更尊重隐私
                Referer：该页面的来源URL(适用于所有类型的请求，会精确到详细页面地址，csrf拦截           常用到这个字段)
                User-Agent：用户客户端的一些必要信息，如UA头部等
            常用响应头：
                Access-Control-Allow-Headers: 服务器端允许的请求Headers
                Access-Control-Allow-Methods: 服务器端允许的请求方法
                Access-Control-Allow-Origin: 服务器端允许的请求Origin头部（譬如为*）
                Content-Type：服务端返回的实体内容的类型
                Date：数据从服务器发送的时间
                Cache-Control：告诉浏览器或其他客户，什么环境可以安全的缓存文档
                Last-Modified：请求资源的最后修改时间
                Expires：应该在什么时候认为文档已经过期,从而不再缓存它
                Max-age：客户端的本地资源应该缓存多少秒，开启了Cache-Control后有效
                ETag：请求变量的实体标签的当前值
                Set-Cookie：设置和页面关联的cookie，服务器通过这个头部把cookie传给客户端
                Keep-Alive：如果客户端有keep-alive，服务端也会有响应（如timeout=38）
                Server：服务器的一些相关信息
`       cookie以及优化`
            客户端在域名A下有cookie（这个可以是登陆时由服务端写入的）
            然后在域名A下有一个页面，页面中有很多依赖的静态资源（都是域名A的，譬如有20个静          态资源）
            此时就有一个问题，页面加载，请求这些静态资源时，浏览器会默认带上cookie
            也就是说，这20个静态资源的http请求，每一个都得带上cookie，而实际上静态资源并不          需要cookie验证
            此时就造成了较为严重的浪费，而且也降低了访问速度（因为内容更多了）
            优化：
            将静态资源分组，分别放到不同的子域名下
            而子域名请求时，是不会带上父级域名的cookie的，所以就避免了浪费
            在移动端，如果请求的域名数过多，会降低请求速度（因为域名整套解析流程是很耗费时间的，而且移动端一般带宽都比不上pc）
            此时就需要用到一种优化方案： dns-prefetch（让浏览器空闲时提前解析dns域名，不过也请合理使用，勿滥用）
`       http 2.0`
            * 与HTTP1.1的不同点
            http1.1中，每请求一个资源，都是需要开启一个tcp/ip连接的，所以对应的结果是，每一个资源对应一个tcp/ip请求，由于tcp/ip本身有并发数限制，所以当资源一多，速度就显著慢下来
            http2.0中，一个tcp/ip请求可以请求多个资源，也就是说，只要一次tcp/ip请求，就可以请求若干个资源，分割成更小的帧请求，速度明显提升。
            * HTTP2.0特性
            多路复用（一个TCP/IP连接跨域请求多个资源）
            首部压缩（http头部压缩，减少体积）
            二进制分帧（在应用层跟传送层之间增加了一个二进制分帧层，改进传输性能，实现低延迟和高吞吐量）
            服务器端推送（服务器跨域对客户端的一个请求发出多个响应，可以主动通知客户端）
            请求优先级（如果流被赋予了优先级，它就会基于中国优先级来处理）
`       https`
        在请求前，会建立ssl链接，确保接下来的通信都是加密的，无法被轻易截取分析
        SSL/TLS的握手流程
        1. 浏览器请求建立SSL连接，并向服务端发送一个随机数Clint random和客户端支持的加密算法（明文）
        2. 服务端选了一个加密算法与Hash算法，回复一个随机数Server random，同事赠送证书一份
        3. 浏览器收到证书后
            * 验证证书真假
            * 产生随机数Premaster secret， 然后从证书中拿加密方法加密发送给服务器
            * 利用Client random、Server random和Premaster secret 通过一定算法生产 session key
            * 使用刚刚约定好的Hash算法解密， 并用session key对消息加密，并发送
        4. 服务端收到浏览器
            解密解密解密
        5. 浏览器继续解密，如果OK，握手结束
3. 缓存问题，HTTP的缓存
    强缓存（200 from cache）和弱缓存（304）
    强缓存（ 200fromcache）时，浏览器如果判断本地缓存未过期，就直接使用，无需发起http请求
    协商缓存（ 304）时，浏览器会向服务端发起http请求，然后服务端告诉浏览器文件未改变，让浏览器使用本地缓存
    强制缓存控制
    (http1.1) Cache-Control/Max-Age
    (http1.0) Pragma/Expires
    协商缓存控制
    (http1.1) If-None-Match/E-tag
    (http1.0) if-Modified-Since/Last-Modified
4. 解析页面流程
    1. 解析HTML，构建DOM树
    2. 解析CSS，生成CSS规则树
    3. 合并DOM树和CSS规则，生成render树
    4. 布局render树（Layout/reflow），负责各元素尺寸、位置的计算
    5. 绘制render树（paint），绘制页面像素信息
    6. 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕

    Layout，也称为Reflow，即回流。一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树

    Repaint，即重绘。意味着元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就可以了

    回流的成本开销要高于重绘，而且一个节点的回流往往回导致子节点以及同级节点的回流，所以优化方案中一般都包括，尽量避免回流。

    * 什么会引起回流?
        1. 页面渲染初始化
        2. DOM结构改变，比如删除了某个节点
        3. render树变化，比如减少了padding
        4. 窗口resize
        5. 最复杂的一种：获取某些属性，引发回流。

    很多浏览器会对回流做优化，会等到数量足够时做一次批处理回流，但是除了render树的  直接变化，当获取一些属性时，浏览器为了获得正确的值也会触发回流，这样使得浏览器优  化无效，包括：
    offset(Top/Left/Width/Height)
    scroll(Top/Left/Width/Height)
    cilent(Top/Left/Width/Height)
    width,height
    调用了getComputedStyle()或者IE的currentStyle

    回流伴随着重绘，优化方案：
    1. 减少逐项更改样式，最好一次性更改style，或者将样式定义为class并一次性更新
    2. 避免循环操作dom，创建一个documentFragment或div，在它上面应用所有DOM操作，最后再把它添加到window.document
    3. 避免多次读取offset等属性。无法避免则将它们缓存到变量
    4. 将复杂的元素绝对定位或固定定位，使得它脱离文档流，否则回流代价会很高
```  
